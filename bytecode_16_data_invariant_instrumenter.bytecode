============ after processor `data_invariant_instrumenter` ================

[variant verification]
public fun Bbay::add_items($t0|account: signer, $t1|item_id: u64, $t2|item_name: vector<u64>, $t3|item_quantity: u64, $t4|item_price: u64, $t5|selling_status: bool) {
     var $t6|i: u64
     var $t7|num_of_products: &mut u64
     var $t8|owner_data: &mut Bbay::Owner
     var $t9|product_data: &mut Bbay::Products
     var $t10: u64
     var $t11: address
     var $t12: num
     var $t13: &mut Bbay::Owner
     var $t14: table::Table<address, address>
     var $t15: address
     var $t16: address
     var $t17: &mut Bbay::Products
     var $t18: &mut u64
     var $t19: u64
     var $t20: u64
     var $t21: bool
     var $t22: u64
     var $t23: bool
     var $t24: u64
     var $t25: u64
     var $t26: u64
     var $t27: u64
     var $t28: u64
     var $t29: &mut table::Table<u64, u64>
     var $t30: &mut table::Table<u64, u64>
     var $t31: &mut table::Table<u64, bool>
     var $t32: &mut vector<u64>
     var $t33: &mut table::Table<u64, vector<u64>>
     var $t34: &mut table::Table<u64, bool>
     var $t35: bool
  0: assume WellFormed($t0)
  1: assume WellFormed($t1)
  2: assume WellFormed($t2)
  3: assume WellFormed($t3)
  4: assume WellFormed($t4)
  5: assume WellFormed($t5)
  6: assume forall $rsc: Bbay::Owner: ResourceDomain<Bbay::Owner>(): WellFormed($rsc)
  7: assume forall $rsc: Bbay::Products: ResourceDomain<Bbay::Products>(): WellFormed($rsc)
  8: trace_local[account]($t0)
  9: trace_local[item_id]($t1)
 10: trace_local[item_name]($t2)
 11: trace_local[item_quantity]($t3)
 12: trace_local[item_price]($t4)
 13: trace_local[selling_status]($t5)
 14: $t10 := 0
 15: trace_local[i]($t10)
 16: $t11 := signer::address_of($t0) on_abort goto 109 with $t12
 17: $t13 := borrow_global<Bbay::Owner>($t11) on_abort goto 109 with $t12
 18: trace_local[owner_data]($t13)
 19: $t14 := get_field<Bbay::Owner>.resource_account($t13)
 20: $t15 := signer::address_of($t0) on_abort goto 109 with $t12
 21: $t16 := table::borrow<address, address>($t14, $t15) on_abort goto 109 with $t12
 22: $t17 := borrow_global<Bbay::Products>($t16) on_abort goto 109 with $t12
 23: trace_local[product_data]($t17)
 24: $t18 := borrow_field<Bbay::Owner>.num_of_products_added($t13)
 25: trace_local[num_of_products]($t18)
 26: label L5
 27: $t6 := havoc[val]()
 28: assume WellFormed($t6)
 29: $t19 := havoc[val]()
 30: assume WellFormed($t19)
 31: $t20 := havoc[val]()
 32: assume WellFormed($t20)
 33: $t21 := havoc[val]()
 34: assume WellFormed($t21)
 35: $t22 := havoc[val]()
 36: assume WellFormed($t22)
 37: $t23 := havoc[val]()
 38: assume WellFormed($t23)
 39: $t24 := havoc[val]()
 40: assume WellFormed($t24)
 41: $t25 := havoc[val]()
 42: assume WellFormed($t25)
 43: $t26 := havoc[val]()
 44: assume WellFormed($t26)
 45: $t27 := havoc[val]()
 46: assume WellFormed($t27)
 47: $t28 := havoc[val]()
 48: assume WellFormed($t28)
 49: $t17 := havoc[mut]()
 50: assume WellFormed($t17)
 51: $t18 := havoc[mut]()
 52: assume WellFormed($t18)
 53: $t29 := havoc[mut_all]()
 54: assume WellFormed($t29)
 55: $t30 := havoc[mut_all]()
 56: assume WellFormed($t30)
 57: $t31 := havoc[mut_all]()
 58: assume WellFormed($t31)
     # info: enter loop, variable(s) i havocked and reassigned
 59: trace_local[i]($t6)
 60: assume Not(AbortFlag())
 61: $t19 := read_ref($t18)
 62: $t20 := +($t19, $t3) on_abort goto 109 with $t12
 63: $t21 := <=($t6, $t20)
 64: if ($t21) goto 111 else goto 89
 65: label L1
 66: label L2
 67: $t22 := read_ref($t18)
 68: $t23 := >($t6, $t22)
 69: if ($t23) goto 70 else goto 114
 70: label L4
 71: $t29 := borrow_field<Bbay::Products>.sr_number($t17)
 72: table::add<u64, u64>($t29, $t6, $t1) on_abort goto 109 with $t12
 73: write_back[Reference($t17).sr_number (table::Table<u64, u64>)]($t29)
 74: $t30 := borrow_field<Bbay::Products>.item_price($t17)
 75: table::add<u64, u64>($t30, $t6, $t4) on_abort goto 109 with $t12
 76: write_back[Reference($t17).item_price (table::Table<u64, u64>)]($t30)
 77: $t31 := borrow_field<Bbay::Products>.item_on_selling($t17)
 78: table::add<u64, bool>($t31, $t6, $t5) on_abort goto 109 with $t12
 79: write_back[Reference($t17).item_on_selling (table::Table<u64, bool>)]($t31)
 80: label L3
 81: $t24 := read_ref($t18)
 82: $t25 := 1
 83: $t26 := +($t24, $t25) on_abort goto 109 with $t12
 84: write_ref($t18, $t26)
 85: $t27 := 1
 86: $t28 := +($t6, $t27) on_abort goto 109 with $t12
 87: trace_local[i]($t28)
 88: goto 105
 89: label L0
 90: write_back[Reference($t13).num_of_products_added (u64)]($t18)
 91: write_back[Bbay::Owner@]($t13)
 92: destroy($t18)
 93: $t32 := borrow_field<Bbay::Products>.item_id($t17)
 94: vector::push_back<u64>($t32, $t1) on_abort goto 109 with $t12
 95: write_back[Reference($t17).item_id (vector<u64>)]($t32)
 96: $t33 := borrow_field<Bbay::Products>.item_name($t17)
 97: table::add<u64, vector<u64>>($t33, $t1, $t2) on_abort goto 109 with $t12
 98: write_back[Reference($t17).item_name (table::Table<u64, vector<u64>>)]($t33)
 99: $t34 := borrow_field<Bbay::Products>.item_sold($t17)
100: $t35 := false
101: table::add<u64, bool>($t34, $t1, $t35) on_abort goto 109 with $t12
102: write_back[Reference($t17).item_sold (table::Table<u64, bool>)]($t34)
103: write_back[Bbay::Products@]($t17)
104: goto 107
     # Loop invariant checking block for the loop started with header: L5
105: label L6
106: stop()
107: label L7
108: return ()
109: label L8
110: abort($t12)
111: label L9
112: destroy($t13)
113: goto 65
114: label L10
115: destroy($t17)
116: goto 80
}


[variant baseline]
public fun Bbay::get_resource_account($t0|addr: address): address {
     var $t1: address
     var $t2: Bbay::Owner
     var $t3: num
     var $t4: table::Table<address, address>
     var $t5: address
  0: trace_local[addr]($t0)
  1: $t1 := 0x1a
  2: $t2 := get_global<Bbay::Owner>($t1) on_abort goto 8 with $t3
  3: $t4 := get_field<Bbay::Owner>.resource_account($t2)
  4: $t5 := table::borrow<address, address>($t4, $t0) on_abort goto 8 with $t3
  5: trace_return[0]($t5)
  6: label L1
  7: return $t5
  8: label L2
  9: abort($t3)
}


[variant verification]
public fun Bbay::get_resource_account($t0|addr: address): address {
     var $t1: address
     var $t2: Bbay::Owner
     var $t3: num
     var $t4: table::Table<address, address>
     var $t5: address
  0: assume WellFormed($t0)
  1: assume forall $rsc: Bbay::Owner: ResourceDomain<Bbay::Owner>(): WellFormed($rsc)
  2: trace_local[addr]($t0)
  3: $t1 := 0x1a
  4: $t2 := get_global<Bbay::Owner>($t1) on_abort goto 10 with $t3
  5: $t4 := get_field<Bbay::Owner>.resource_account($t2)
  6: $t5 := table::borrow<address, address>($t4, $t0) on_abort goto 10 with $t3
  7: trace_return[0]($t5)
  8: label L1
  9: return $t5
 10: label L2
 11: abort($t3)
}


[variant verification]
fun Bbay::init_module($t0|account: signer) {
     var $t1: address
     var $t2: num
     var $t3: u64
     var $t4: u64
     var $t5: table::Table<address, address>
     var $t6: Bbay::Owner
  0: assume WellFormed($t0)
  1: assume forall $rsc: Bbay::Owner: ResourceDomain<Bbay::Owner>(): WellFormed($rsc)
  2: trace_local[account]($t0)
  3: $t1 := signer::address_of($t0) on_abort goto 11 with $t2
  4: $t3 := 0
  5: $t4 := 0
  6: $t5 := table::new<address, address>() on_abort goto 11 with $t2
  7: $t6 := pack Bbay::Owner($t1, $t3, $t4, $t5)
  8: move_to<Bbay::Owner>($t6, $t0) on_abort goto 11 with $t2
  9: label L1
 10: return ()
 11: label L2
 12: abort($t2)
}


[variant verification]
public fun Bbay::order<#0>($t0|account: signer, $t1|item_id: u64, $t2|sr_no: u64, $t3|prepaid: bool) {
     var $t4|product_data: Bbay::Products
     var $t5|resource_account: address
     var $t6|resource_account_signer: signer
     var $t7|user_data: &mut Bbay::User
     var $t8: address
     var $t9: num
     var $t10: address
     var $t11: Bbay::ResourceAccountSignerCap
     var $t12: account::SignerCapability
     var $t13: address
     var $t14: signer
     var $t15: &mut Bbay::User
     var $t16: address
     var $t17: Bbay::Products
     var $t18: &mut vector<u64>
     var $t19: &mut vector<u64>
     var $t20: u64
     var $t21: bool
     var $t22: bool
     var $t23: address
     var $t24: table::Table<u64, u64>
     var $t25: u64
     var $t26: option::Option<optional_aggregator::OptionalAggregator>
     var $t27: address
     var $t28: coin::CoinStore<#0>
     var $t29: coin::CoinStore<#0>
     var $t30: &mut vector<u64>
     var $t31: u64
     var $t32: &mut vector<u64>
     var $t33: u64
  0: assume WellFormed($t0)
  1: assume WellFormed($t1)
  2: assume WellFormed($t2)
  3: assume WellFormed($t3)
  4: assume forall $rsc: coin::CoinInfo<#0>: ResourceDomain<coin::CoinInfo<#0>>(): And(WellFormed($rsc), And(Le(Len<optional_aggregator::OptionalAggregator>(select option::Option.vec(select coin::CoinInfo.supply($rsc))), 1), forall $elem: optional_aggregator::OptionalAggregator: select option::Option.vec(select coin::CoinInfo.supply($rsc)): And(And(And(And(And(Iff(option::$is_some<aggregator::Aggregator>(select optional_aggregator::OptionalAggregator.aggregator($elem)), option::$is_none<optional_aggregator::Integer>(select optional_aggregator::OptionalAggregator.integer($elem))), Iff(option::$is_some<optional_aggregator::Integer>(select optional_aggregator::OptionalAggregator.integer($elem)), option::$is_none<aggregator::Aggregator>(select optional_aggregator::OptionalAggregator.aggregator($elem)))), Implies(option::$is_some<optional_aggregator::Integer>(select optional_aggregator::OptionalAggregator.integer($elem)), Le(select optional_aggregator::Integer.value(option::$borrow<optional_aggregator::Integer>(select optional_aggregator::OptionalAggregator.integer($elem))), select optional_aggregator::Integer.limit(option::$borrow<optional_aggregator::Integer>(select optional_aggregator::OptionalAggregator.integer($elem)))))), Implies(option::$is_some<aggregator::Aggregator>(select optional_aggregator::OptionalAggregator.aggregator($elem)), Le(aggregator::spec_aggregator_get_val(option::$borrow<aggregator::Aggregator>(select optional_aggregator::OptionalAggregator.aggregator($elem))), aggregator::spec_get_limit(option::$borrow<aggregator::Aggregator>(select optional_aggregator::OptionalAggregator.aggregator($elem)))))), Le(Len<aggregator::Aggregator>(select option::Option.vec(select optional_aggregator::OptionalAggregator.aggregator($elem))), 1)), Le(Len<optional_aggregator::Integer>(select option::Option.vec(select optional_aggregator::OptionalAggregator.integer($elem))), 1))))
  5: assume forall $rsc: coin::CoinStore<#0>: ResourceDomain<coin::CoinStore<#0>>(): WellFormed($rsc)
  6: assume forall $rsc: coin::Ghost$supply<#0>: ResourceDomain<coin::Ghost$supply<#0>>(): WellFormed($rsc)
  7: assume exists<coin::Ghost$supply<#0>>(0x0)
  8: assume forall $rsc: coin::Ghost$aggregate_supply<#0>: ResourceDomain<coin::Ghost$aggregate_supply<#0>>(): WellFormed($rsc)
  9: assume exists<coin::Ghost$aggregate_supply<#0>>(0x0)
 10: assume forall $rsc: Bbay::Owner: ResourceDomain<Bbay::Owner>(): WellFormed($rsc)
 11: assume forall $rsc: Bbay::Products: ResourceDomain<Bbay::Products>(): WellFormed($rsc)
 12: assume forall $rsc: Bbay::ResourceAccountSignerCap: ResourceDomain<Bbay::ResourceAccountSignerCap>(): WellFormed($rsc)
 13: assume forall $rsc: Bbay::User: ResourceDomain<Bbay::User>(): WellFormed($rsc)
 14: trace_local[account]($t0)
 15: trace_local[item_id]($t1)
 16: trace_local[sr_no]($t2)
 17: trace_local[prepaid]($t3)
 18: $t8 := signer::address_of($t0) on_abort goto 65 with $t9
 19: $t10 := Bbay::get_resource_account($t8) on_abort goto 65 with $t9
 20: trace_local[resource_account]($t10)
 21: $t11 := get_global<Bbay::ResourceAccountSignerCap>($t10) on_abort goto 65 with $t9
 22: $t12 := get_field<Bbay::ResourceAccountSignerCap>.signer_cap($t11)
 23: assume Identical($t13, select account::SignerCapability.account($t12))
 24: $t14 := account::create_signer_with_capability($t12) on_abort goto 65 with $t9
 25: trace_local[resource_account_signer]($t14)
 26: $t15 := borrow_global<Bbay::User>($t10) on_abort goto 65 with $t9
 27: trace_local[user_data]($t15)
 28: $t16 := 0x1a
 29: $t17 := get_global<Bbay::Products>($t16) on_abort goto 65 with $t9
 30: trace_local[product_data]($t17)
 31: $t18 := borrow_field<Bbay::User>.orders($t15)
 32: vector::push_back<u64>($t18, $t1) on_abort goto 65 with $t9
 33: write_back[Reference($t15).orders (vector<u64>)]($t18)
 34: $t19 := borrow_field<Bbay::User>.order_status($t15)
 35: $t20 := 1
 36: vector::push_back<u64>($t19, $t20) on_abort goto 65 with $t9
 37: write_back[Reference($t15).order_status (vector<u64>)]($t19)
 38: $t21 := true
 39: $t22 := ==($t3, $t21)
 40: if ($t22) goto 41 else goto 56
 41: label L1
 42: $t23 := 0x1a
 43: $t24 := get_field<Bbay::Products>.item_price($t17)
 44: $t25 := table::borrow<u64, u64>($t24, $t2) on_abort goto 65 with $t9
 45: assume Identical($t26, select coin::CoinInfo.supply(global<coin::CoinInfo<#0>>(select type_info::TypeInfo.account_address(type_info::$type_of<#0>()))))
 46: assume Identical($t27, signer::$address_of($t14))
 47: assume Identical($t28, global<coin::CoinStore<#0>>($t27))
 48: assume Identical($t29, global<coin::CoinStore<#0>>($t23))
 49: coin::transfer<#0>($t14, $t23, $t25) on_abort goto 65 with $t9
 50: $t30 := borrow_field<Bbay::User>.payment_status($t15)
 51: $t31 := 2
 52: vector::push_back<u64>($t30, $t31) on_abort goto 65 with $t9
 53: write_back[Reference($t15).payment_status (vector<u64>)]($t30)
 54: write_back[Bbay::User@]($t15)
 55: goto 62
 56: label L0
 57: $t32 := borrow_field<Bbay::User>.payment_status($t15)
 58: $t33 := 1
 59: vector::push_back<u64>($t32, $t33) on_abort goto 65 with $t9
 60: write_back[Reference($t15).payment_status (vector<u64>)]($t32)
 61: write_back[Bbay::User@]($t15)
 62: label L2
 63: label L3
 64: return ()
 65: label L4
 66: abort($t9)
}


[variant verification]
public fun Bbay::register_account($t0|account: signer, $t1|seed: vector<u8>) {
     var $t2|owner_data: &mut Bbay::Owner
     var $t3|resource_account: signer
     var $t4|resource_account_signer_cap: account::SignerCapability
     var $t5: address
     var $t6: &mut Bbay::Owner
     var $t7: num
     var $t8: u64
     var $t9: u64
     var $t10: u64
     var $t11: &mut u64
     var $t12: address
     var $t13: address
     var $t14: account::Account
     var $t15: vector<u8>
     var $t16: signer
     var $t17: account::SignerCapability
     var $t18: u64
     var $t19: vector<u64>
     var $t20: vector<u64>
     var $t21: vector<u64>
     var $t22: Bbay::User
     var $t23: option::Option<optional_aggregator::OptionalAggregator>
     var $t24: address
     var $t25: account::Account
     var $t26: Bbay::ResourceAccountSignerCap
  0: assume WellFormed($t0)
  1: assume WellFormed($t1)
  2: assume forall $rsc: account::Account: ResourceDomain<account::Account>(): And(WellFormed($rsc), And(Le(Len<address>(select option::Option.vec(select account::CapabilityOffer.for(select account::Account.rotation_capability_offer($rsc)))), 1), Le(Len<address>(select option::Option.vec(select account::CapabilityOffer.for(select account::Account.signer_capability_offer($rsc)))), 1)))
  3: assume forall $rsc: coin::CoinInfo<aptos_coin::AptosCoin>: ResourceDomain<coin::CoinInfo<aptos_coin::AptosCoin>>(): And(WellFormed($rsc), And(Le(Len<optional_aggregator::OptionalAggregator>(select option::Option.vec(select coin::CoinInfo.supply($rsc))), 1), forall $elem: optional_aggregator::OptionalAggregator: select option::Option.vec(select coin::CoinInfo.supply($rsc)): And(And(And(And(And(Iff(option::$is_some<aggregator::Aggregator>(select optional_aggregator::OptionalAggregator.aggregator($elem)), option::$is_none<optional_aggregator::Integer>(select optional_aggregator::OptionalAggregator.integer($elem))), Iff(option::$is_some<optional_aggregator::Integer>(select optional_aggregator::OptionalAggregator.integer($elem)), option::$is_none<aggregator::Aggregator>(select optional_aggregator::OptionalAggregator.aggregator($elem)))), Implies(option::$is_some<optional_aggregator::Integer>(select optional_aggregator::OptionalAggregator.integer($elem)), Le(select optional_aggregator::Integer.value(option::$borrow<optional_aggregator::Integer>(select optional_aggregator::OptionalAggregator.integer($elem))), select optional_aggregator::Integer.limit(option::$borrow<optional_aggregator::Integer>(select optional_aggregator::OptionalAggregator.integer($elem)))))), Implies(option::$is_some<aggregator::Aggregator>(select optional_aggregator::OptionalAggregator.aggregator($elem)), Le(aggregator::spec_aggregator_get_val(option::$borrow<aggregator::Aggregator>(select optional_aggregator::OptionalAggregator.aggregator($elem))), aggregator::spec_get_limit(option::$borrow<aggregator::Aggregator>(select optional_aggregator::OptionalAggregator.aggregator($elem)))))), Le(Len<aggregator::Aggregator>(select option::Option.vec(select optional_aggregator::OptionalAggregator.aggregator($elem))), 1)), Le(Len<optional_aggregator::Integer>(select option::Option.vec(select optional_aggregator::OptionalAggregator.integer($elem))), 1))))
  4: assume forall $rsc: coin::CoinStore<aptos_coin::AptosCoin>: ResourceDomain<coin::CoinStore<aptos_coin::AptosCoin>>(): WellFormed($rsc)
  5: assume forall $rsc: coin::Ghost$supply<aptos_coin::AptosCoin>: ResourceDomain<coin::Ghost$supply<aptos_coin::AptosCoin>>(): WellFormed($rsc)
  6: assume exists<coin::Ghost$supply<aptos_coin::AptosCoin>>(0x0)
  7: assume forall $rsc: coin::Ghost$aggregate_supply<aptos_coin::AptosCoin>: ResourceDomain<coin::Ghost$aggregate_supply<aptos_coin::AptosCoin>>(): WellFormed($rsc)
  8: assume exists<coin::Ghost$aggregate_supply<aptos_coin::AptosCoin>>(0x0)
  9: assume forall $rsc: Bbay::Owner: ResourceDomain<Bbay::Owner>(): WellFormed($rsc)
 10: assume forall $rsc: Bbay::ResourceAccountSignerCap: ResourceDomain<Bbay::ResourceAccountSignerCap>(): WellFormed($rsc)
 11: assume forall $rsc: Bbay::User: ResourceDomain<Bbay::User>(): WellFormed($rsc)
 12: trace_local[account]($t0)
 13: trace_local[seed]($t1)
 14: $t5 := 0x1a
 15: $t6 := borrow_global<Bbay::Owner>($t5) on_abort goto 45 with $t7
 16: trace_local[owner_data]($t6)
 17: $t8 := get_field<Bbay::Owner>.user_count($t6)
 18: $t9 := 1
 19: $t10 := +($t8, $t9) on_abort goto 45 with $t7
 20: $t11 := borrow_field<Bbay::Owner>.user_count($t6)
 21: write_ref($t11, $t10)
 22: write_back[Reference($t6).user_count (u64)]($t11)
 23: assume Identical($t12, signer::$address_of($t0))
 24: assume Identical($t13, account::spec_create_resource_address($t12, $t1))
 25: assume Identical($t14, global<account::Account>($t13))
 26: assume Identical($t15, bcs::$to_bytes<address>($t13))
 27: ($t16, $t17) := account::create_resource_account($t0, $t1) on_abort goto 45 with $t7
 28: trace_local[resource_account_signer_cap]($t17)
 29: trace_local[resource_account]($t16)
 30: $t18 := get_field<Bbay::Owner>.user_count($t6)
 31: write_back[Bbay::Owner@]($t6)
 32: $t19 := vector::empty<u64>() on_abort goto 45 with $t7
 33: $t20 := vector::empty<u64>() on_abort goto 45 with $t7
 34: $t21 := vector::empty<u64>() on_abort goto 45 with $t7
 35: $t22 := pack Bbay::User($t18, $t19, $t20, $t21)
 36: move_to<Bbay::User>($t22, $t16) on_abort goto 45 with $t7
 37: assume Identical($t23, select coin::CoinInfo.supply(global<coin::CoinInfo<aptos_coin::AptosCoin>>(select type_info::TypeInfo.account_address(type_info::$type_of<aptos_coin::AptosCoin>()))))
 38: assume Identical($t24, signer::$address_of($t16))
 39: assume Identical($t25, global<account::Account>($t24))
 40: coin::register<aptos_coin::AptosCoin>($t16) on_abort goto 45 with $t7
 41: $t26 := pack Bbay::ResourceAccountSignerCap($t17)
 42: move_to<Bbay::ResourceAccountSignerCap>($t26, $t16) on_abort goto 45 with $t7
 43: label L1
 44: return ()
 45: label L2
 46: abort($t7)
}


[variant verification]
public fun Bbay::trigger_delivery() {
  0: label L1
  1: return ()
}
